{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"dev/contributing/","title":"Contributing","text":"<p>We welcome contributions to bhut! This guide will help you set up a development environment and understand our development workflow.</p>"},{"location":"dev/contributing/#development-setup","title":"Development Setup","text":""},{"location":"dev/contributing/#1-clone-and-install","title":"1. Clone and Install","text":"<pre><code># Clone the repository\ngit clone https://github.com/username/bhut.git\ncd bhut\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode with all dependencies\npip install -e \".[dev,test,docs]\"\n</code></pre>"},{"location":"dev/contributing/#2-install-development-tools","title":"2. Install Development Tools","text":"<pre><code># Install pre-commit hooks for automatic formatting\npre-commit install\n</code></pre>"},{"location":"dev/contributing/#running-tests","title":"Running Tests","text":""},{"location":"dev/contributing/#full-test-suite","title":"Full Test Suite","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=bhut --cov-report=html\n</code></pre>"},{"location":"dev/contributing/#specific-test-categories","title":"Specific Test Categories","text":"<pre><code># Unit tests only\npytest tests/unit/\n\n# Integration tests\npytest tests/integration/\n\n# Performance tests\npytest tests/performance/\n\n# Edge cases\npytest tests/edge_cases/\n</code></pre>"},{"location":"dev/contributing/#code-quality","title":"Code Quality","text":""},{"location":"dev/contributing/#formatting-and-linting","title":"Formatting and Linting","text":"<p>We use ruff for both formatting and linting:</p> <pre><code># Format code\nruff format .\n\n# Check and fix linting issues\nruff check . --fix\n\n# Check without fixing\nruff check .\n</code></pre>"},{"location":"dev/contributing/#type-checking","title":"Type Checking","text":"<p>We use mypy for static type checking:</p> <pre><code># Run type checking\nmypy bhut/\n\n# Run with strict mode\nmypy --strict bhut/\n</code></pre>"},{"location":"dev/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"dev/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Test your changes: Ensure all tests pass</li> <li>Add tests: For new features or bug fixes</li> <li>Update docs: If you change the public API</li> <li>Check types: Run mypy without errors</li> <li>Format code: Run ruff format</li> </ol>"},{"location":"dev/contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li>[ ] Tests pass locally</li> <li>[ ] New code has tests</li> <li>[ ] Documentation updated if needed</li> <li>[ ] Type hints added for new code</li> <li>[ ] Descriptive commit messages</li> <li>[ ] No unnecessary dependencies added</li> </ul>"},{"location":"dev/contributing/#commit-message-format","title":"Commit Message Format","text":"<pre><code>type: short description\n\nLonger explanation if needed.\n\nFixes #123\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>test</code>, <code>refactor</code>, <code>perf</code>, <code>chore</code></p>"},{"location":"dev/contributing/#development-tips","title":"Development Tips","text":"<ul> <li>Use descriptive variable names and add type hints</li> <li>Keep functions small and focused</li> <li>Add docstrings for public API</li> <li>Consider performance implications for hot paths</li> <li>Test edge cases (empty arrays, single particles, etc.)</li> </ul>"},{"location":"dev/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue for bugs or feature requests</li> <li>Start discussions for design questions</li> <li>Check existing issues before creating new ones</li> </ul>"},{"location":"dev/design/","title":"Design Architecture","text":"<p>This document outlines the high-level architecture and design decisions of the bhut library.</p>"},{"location":"dev/design/#overview","title":"Overview","text":"<p>bhut is structured as a modular library with clear separation of concerns:</p> <pre><code>bhut/\n\u251c\u2500\u2500 api.py          # Public API functions\n\u251c\u2500\u2500 backends/       # Computational backends\n\u251c\u2500\u2500 tree/           # Tree data structures\n\u251c\u2500\u2500 traverse/       # Tree traversal algorithms\n\u251c\u2500\u2500 space/          # Spatial data structures\n\u2514\u2500\u2500 utils/          # Utilities and helpers\n</code></pre>"},{"location":"dev/design/#core-components","title":"Core Components","text":""},{"location":"dev/design/#1-backends-bhutbackends","title":"1. Backends (<code>bhut.backends</code>)","text":"<p>The backend system provides pluggable computational engines:</p> <ul> <li><code>numpy_</code>: Pure NumPy implementation for small to medium datasets</li> <li><code>dask_</code>: Distributed computing for large datasets</li> <li><code>base</code>: Abstract base class defining the backend interface</li> </ul> <pre><code># Backend selection\ntree = bhut.Tree(positions, masses, backend='numpy')\ntree = bhut.Tree(positions, masses, backend='dask')\n</code></pre>"},{"location":"dev/design/#2-tree-structure-bhuttree","title":"2. Tree Structure (<code>bhut.tree</code>)","text":"<p>Core tree data structures and operations:</p> <ul> <li><code>node.py</code>: Tree node implementation (internal and leaf nodes)</li> <li><code>build.py</code>: Tree construction algorithms</li> <li><code>refit.py</code>: Efficient tree updating for dynamic simulations</li> </ul>"},{"location":"dev/design/#3-traversal-bhuttraverse","title":"3. Traversal (<code>bhut.traverse</code>)","text":"<p>Tree traversal algorithms implementing the Barnes-Hut method:</p> <ul> <li><code>bh.py</code>: Main Barnes-Hut traversal algorithm</li> <li><code>kernels.py</code>: Force/potential calculation kernels</li> </ul>"},{"location":"dev/design/#4-spatial-structures-bhutspace","title":"4. Spatial Structures (<code>bhut.space</code>)","text":"<p>Spatial data structures and utilities:</p> <ul> <li><code>bbox.py</code>: Bounding box operations for tree subdivision</li> </ul>"},{"location":"dev/design/#5-utilities-bhututils","title":"5. Utilities (<code>bhut.utils</code>)","text":"<p>Helper functions and optimizations:</p> <ul> <li><code>morton.py</code>: Morton encoding for spatial ordering</li> </ul>"},{"location":"dev/design/#algorithm-flow","title":"Algorithm Flow","text":"<pre><code>flowchart TD\n    A[Input: positions, masses] --&gt; B[Tree Construction]\n    B --&gt; C[Recursive Subdivision]\n    C --&gt; D[Compute Node Properties]\n    D --&gt; E[Barnes-Hut Traversal]\n    E --&gt; F[Force/Potential Calculation]\n    F --&gt; G[Output: forces/potentials]</code></pre> <p>Note: Mermaid diagram will be rendered in the documentation</p>"},{"location":"dev/design/#design-principles","title":"Design Principles","text":""},{"location":"dev/design/#1-modularity","title":"1. Modularity","text":"<p>Each component has a single responsibility and clear interfaces.</p>"},{"location":"dev/design/#2-performance","title":"2. Performance","text":"<ul> <li>Efficient tree construction using Morton ordering</li> <li>Vectorized operations where possible</li> <li>Memory-conscious data structures</li> </ul>"},{"location":"dev/design/#3-flexibility","title":"3. Flexibility","text":"<ul> <li>Multiple backends for different scales</li> <li>Configurable parameters (theta, leaf_size, etc.)</li> <li>Support for both 2D and 3D problems</li> </ul>"},{"location":"dev/design/#4-extensibility","title":"4. Extensibility","text":"<ul> <li>Plugin architecture for backends</li> <li>Abstract base classes for easy extension</li> <li>Clear separation of algorithm from implementation</li> </ul>"},{"location":"dev/design/#memory-layout","title":"Memory Layout","text":"<p>The tree uses a compact memory layout for cache efficiency:</p> <ul> <li>Nodes stored in breadth-first order</li> <li>Contiguous arrays for node properties</li> <li>Minimal indirection in hot paths</li> </ul>"},{"location":"dev/design/#threading-and-parallelization","title":"Threading and Parallelization","text":"<ul> <li>NumPy backend: Uses NumPy's built-in parallelization</li> <li>Dask backend: Distributed computation across workers</li> <li>Thread-safe by design for read-only operations</li> </ul>"},{"location":"dev/design/#future-extensions","title":"Future Extensions","text":"<p>Planned architectural improvements:</p> <ul> <li>GPU backend using CuPy/JAX</li> <li>Adaptive mesh refinement</li> <li>Multipole expansions for higher accuracy</li> </ul>"},{"location":"theory/barnes-hut/","title":"Barnes-Hut Algorithm","text":"<p>The Barnes-Hut algorithm is a fast approximate method for computing N-body forces, reducing the computational complexity from O(N\u00b2) to O(N log N).</p>"},{"location":"theory/barnes-hut/#basic-principle","title":"Basic Principle","text":"<p>Instead of computing forces between every pair of particles, the Barnes-Hut algorithm groups distant particles and treats them as a single mass located at their center of mass.</p>"},{"location":"theory/barnes-hut/#tree-construction","title":"Tree Construction","text":"<p>The algorithm builds a spatial tree (quadtree in 2D, octree in 3D) by recursively subdividing space:</p> <ol> <li>Start with a bounding box containing all particles</li> <li>If a region contains more than one particle, subdivide it</li> <li>Continue until each leaf contains at most one particle</li> </ol>"},{"location":"theory/barnes-hut/#force-calculation","title":"Force Calculation","text":"<p>For each particle, traverse the tree and decide whether to:</p> <ul> <li>Use the node: If the node is sufficiently far away (determined by the \u03b8 parameter)</li> <li>Recurse: If the node is too close, examine its children</li> </ul>"},{"location":"theory/barnes-hut/#the-criterion","title":"The \u03b8 Criterion","text":"<p>A node is considered \"far enough\" if:</p> \\[\\frac{s}{d} &lt; \\theta\\] <p>Where: - \\(s\\) = size of the node (width/height of bounding box) - \\(d\\) = distance from particle to node's center of mass - \\(\\theta\\) = accuracy parameter (0 = exact, larger = more approximate)</p>"},{"location":"theory/barnes-hut/#force-equations","title":"Force Equations","text":""},{"location":"theory/barnes-hut/#gravitational-force","title":"Gravitational Force","text":"<p>The gravitational force between two particles is:</p> \\[\\vec{F}_{ij} = -G \\frac{m_i m_j}{|\\vec{r}_{ij}|^3} \\vec{r}_{ij}\\] <p>Where: - \\(G\\) = gravitational constant - \\(m_i, m_j\\) = masses of particles \\(i\\) and \\(j\\) - \\(\\vec{r}_{ij} = \\vec{r}_j - \\vec{r}_i\\) = displacement vector</p>"},{"location":"theory/barnes-hut/#potential-energy","title":"Potential Energy","text":"<p>The gravitational potential at position \\(\\vec{r}_i\\) due to particle \\(j\\) is:</p> \\[\\phi_i = -G \\frac{m_j}{|\\vec{r}_{ij}|}\\]"},{"location":"theory/barnes-hut/#softened-force","title":"Softened Force","text":"<p>To avoid singularities at small distances, a softening parameter \\(\\epsilon\\) is often used:</p> \\[\\vec{F}_{ij} = -G \\frac{m_i m_j}{(|\\vec{r}_{ij}|^2 + \\epsilon^2)^{3/2}} \\vec{r}_{ij}\\]"},{"location":"theory/barnes-hut/#center-of-mass-calculation","title":"Center of Mass Calculation","text":"<p>For each tree node, the center of mass and total mass are computed:</p> \\[\\vec{R}_{cm} = \\frac{\\sum_i m_i \\vec{r}_i}{\\sum_i m_i}\\] \\[M_{total} = \\sum_i m_i\\]"},{"location":"theory/barnes-hut/#multipole-expansion","title":"Multipole Expansion","text":"<p>The Barnes-Hut algorithm can be viewed as a first-order multipole expansion. Higher-order terms can be included for improved accuracy:</p> \\[\\phi(\\vec{r}) = -G \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} \\frac{A_{lm}}{r^{l+1}} Y_l^m(\\theta, \\phi)\\] <p>Where \\(A_{lm}\\) are the multipole moments and \\(Y_l^m\\) are spherical harmonics.</p>"},{"location":"theory/barnes-hut/#algorithm-complexity","title":"Algorithm Complexity","text":"<ul> <li>Tree construction: O(N log N)</li> <li>Force evaluation: O(N log N) for N particles</li> <li>Memory usage: O(N)</li> </ul> <p>The key insight is that the number of nodes at each level of the tree is bounded, leading to the logarithmic factor.</p>"},{"location":"theory/complexity/","title":"Computational Complexity","text":"<p>This page analyzes the computational complexity of the Barnes-Hut algorithm and discusses the accuracy-performance tradeoffs.</p>"},{"location":"theory/complexity/#time-complexity","title":"Time Complexity","text":""},{"location":"theory/complexity/#tree-construction-on-log-n","title":"Tree Construction: O(N log N)","text":"<p>Building the spatial tree requires:</p> <ol> <li>Sorting particles: O(N log N) using Morton ordering</li> <li>Tree assembly: O(N) to build the tree structure</li> <li>Computing node properties: O(N) to calculate centers of mass</li> </ol> <p>The dominating factor is the sorting step, giving overall O(N log N) complexity.</p>"},{"location":"theory/complexity/#force-evaluation-om-log-n","title":"Force Evaluation: O(M log N)","text":"<p>For M target particles querying forces from N source particles:</p> <ul> <li>Tree traversal: Each particle visits O(log N) nodes on average</li> <li>Force calculation: O(1) per node interaction</li> <li>Total: O(M log N)</li> </ul> <p>When M = N (self-force calculation), this becomes O(N log N).</p>"},{"location":"theory/complexity/#comparison-with-direct-methods","title":"Comparison with Direct Methods","text":"Method Time Complexity Accuracy Direct (brute force) O(N\u00b2) Exact Barnes-Hut O(N log N) Approximate Fast Multipole Method O(N) Approximate"},{"location":"theory/complexity/#space-complexity","title":"Space Complexity","text":""},{"location":"theory/complexity/#memory-usage-on","title":"Memory Usage: O(N)","text":"<ul> <li>Particle storage: 3N floats for positions (2N in 2D)</li> <li>Tree nodes: ~4N/3 nodes in worst case (complete tree)</li> <li>Node properties: Center of mass, total mass per node</li> <li>Total: O(N) memory usage</li> </ul>"},{"location":"theory/complexity/#cache-efficiency","title":"Cache Efficiency","text":"<p>The tree structure is optimized for cache performance:</p> <ul> <li>Breadth-first node ordering improves locality</li> <li>Contiguous arrays reduce memory fragmentation</li> <li>Vectorized operations maximize throughput</li> </ul>"},{"location":"theory/complexity/#accuracy-vs-performance","title":"Accuracy vs Performance","text":""},{"location":"theory/complexity/#the-parameter","title":"The \u03b8 Parameter","text":"<p>The accuracy-speed tradeoff is controlled by the \u03b8 (theta) parameter:</p> \\[\\text{Error} \\propto \\theta^2\\] \\[\\text{Speed} \\propto \\frac{1}{\\log(1/\\theta)}\\] \u03b8 Value Relative Error Relative Speed Use Case 0.0 0% (exact) 1\u00d7 (slowest) Validation 0.1 ~1% 2-3\u00d7 High accuracy 0.5 ~25% 5-10\u00d7 Balanced (recommended) 1.0 ~100% 10-20\u00d7 Fast approximation 2.0 ~400% 20-50\u00d7 Very rough estimate"},{"location":"theory/complexity/#error-analysis","title":"Error Analysis","text":"<p>The error in Barnes-Hut comes from two sources:</p> <ol> <li>Approximation error: Treating distant groups as point masses</li> <li>Truncation error: Using first-order multipole expansion</li> </ol> <p>The total relative error is approximately:</p> \\[\\epsilon_{rel} \\approx \\theta^2 \\left(1 + \\frac{s}{2d}\\right)\\] <p>Where s/d is the size-to-distance ratio of the farthest node used in approximation.</p>"},{"location":"theory/complexity/#adaptive-accuracy","title":"Adaptive Accuracy","text":"<p>For applications requiring variable accuracy:</p> <pre><code># High accuracy for nearby interactions\nforces_precise = bhut.force(positions, masses, theta=0.1)\n\n# Lower accuracy for distant background\nforces_approx = bhut.force(positions, masses, theta=1.0)\n</code></pre>"},{"location":"theory/complexity/#scaling-analysis","title":"Scaling Analysis","text":""},{"location":"theory/complexity/#strong-scaling-fixed-problem-size","title":"Strong Scaling (Fixed Problem Size)","text":"<p>Performance with increasing number of processors:</p> <ul> <li>Ideal speedup: Limited by O(log N) tree traversal</li> <li>Communication overhead: Increases with processor count</li> <li>Memory bandwidth: Can become bottleneck</li> </ul>"},{"location":"theory/complexity/#weak-scaling-fixed-work-per-processor","title":"Weak Scaling (Fixed Work per Processor)","text":"<p>Performance with proportionally increasing problem size:</p> <ul> <li>Tree depth: Grows as log N, maintaining efficiency</li> <li>Load balancing: Space-filling curves help distribute work</li> <li>Network communication: Scales well for distributed systems</li> </ul>"},{"location":"theory/complexity/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"theory/complexity/#algorithmic-optimizations","title":"Algorithmic Optimizations","text":"<ol> <li>Morton ordering: Improves cache locality and tree balance</li> <li>Vectorization: Process multiple particles simultaneously</li> <li>Tree reuse: Rebuild only when necessary for dynamic systems</li> </ol>"},{"location":"theory/complexity/#implementation-optimizations","title":"Implementation Optimizations","text":"<ol> <li>Memory pooling: Reduce allocation overhead</li> <li>SIMD instructions: Vectorize force calculations</li> <li>Prefetching: Hide memory latency</li> </ol>"},{"location":"theory/complexity/#parallel-optimizations","title":"Parallel Optimizations","text":"<ol> <li>Shared-memory: OpenMP for multi-core parallelization</li> <li>Distributed-memory: MPI for cluster computing</li> <li>GPU acceleration: CUDA/OpenCL for massively parallel systems</li> </ol>"},{"location":"theory/complexity/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Typical performance on modern hardware:</p> N Particles Direct O(N\u00b2) Barnes-Hut O(N log N) Speedup 1,000 1ms 0.1ms 10\u00d7 10,000 100ms 2ms 50\u00d7 100,000 10s 30ms 333\u00d7 1,000,000 16min 400ms 2,400\u00d7 <p>Benchmarks assume \u03b8 = 0.5 on a modern CPU</p>"}]}